<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>MAGE Algorithm • iglu</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="MAGE Algorithm">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">iglu</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">4.1.6</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../articles/iglu.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/AGP_and_Episodes.html">AGP and Episodes</a></li>
    <li><a class="dropdown-item" href="../articles/lasagna_plots.html">Lasagna Plots in iglu</a></li>
    <li><a class="dropdown-item" href="../articles/MAGE.html">MAGE Algorithm</a></li>
    <li><a class="dropdown-item" href="../articles/metrics_list.html">List of metrics implemented in iglu</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/irinagain/iglu/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>MAGE Algorithm</h1>
                        <h4 data-toc-skip class="author">Nathaniel J.
Fernandes, Nhan Nguyen, Elizabeth Chun, Naresh Punjabi, Irina
Gaynanova</h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/irinagain/iglu/blob/master/vignettes/MAGE.Rmd" class="external-link"><code>vignettes/MAGE.Rmd</code></a></small>
      <div class="d-none name"><code>MAGE.Rmd</code></div>
    </div>

    
    
<p>Mean Amplitude of Glycemic Excursions (MAGE) is a glucose variability
metric that can be applied to continuous glucose monitoring (CGM) data.
From iglu version 3 onward, the package includes two algorithms for MAGE
calculation:</p>
<ol style="list-style-type: lower-roman">
<li><p><code>iglu::mage(., version = 'ma')</code> uses short and long
moving averages to computationally emulate the original
definition,</p></li>
<li><p><code>iglu::mage(., version = 'naive')</code> is a naive
approximation <strong>solely included</strong> for backwards
compatibility with earlier versions of iglu.</p></li>
</ol>
<p>The moving average algorithm was published in the Journal of Diabetes
Science and Technology: <a href="https://doi.org/10.1177/19322968211061165" class="external-link">Open-source Algorithm
to Calculate Mean Amplitude of Glycemic Excursions Using Short and Long
Moving Averages</a>, and the code to reproduce all tests can be found at
the accompanying repository: <a href="https://github.com/Nathaniel-Fernandes/mage_algorithm_data" class="external-link">Nathaniel-Fernandes/mage_algorithm_data</a>.
Below is a supplementary vignette describing the algorithm in more
detail, our design choices, and the methods we used to test it. Some
example code to get started using MAGE in iglu is included in the <a href="#example_code"><em>Implementation</em></a> section.</p>
<div class="section level2">
<h2 id="abstract">Abstract<a class="anchor" aria-label="anchor" href="#abstract"></a>
</h2>
<p><strong>Background</strong>: Glucose variability is increasingly
regarded as a risk factor for diabetes-related complications. The mean
amplitude of glycemic excursions (MAGE) is a common measure of glucose
variability. While its original definition requires manual calculations,
there exist several software programs for automated calculations which
have shown varying degrees of agreement. The objective of this study was
to develop an automated algorithm for MAGE that would achieve high
accuracy against the reference standard of manual calculations and
benchmark it against existing alternatives.</p>
<p><strong>Methods</strong>: Manual calculations of MAGE were performed
on 45 publicly available CGM profiles from a diverse set of patients
(i.e., Type 1 diabetes, Type 2 diabetes, and those without diabetes)
following the definition described in Service et al. [3]. An automated
algorithm for MAGE calculation was developed to identify peaks and
nadirs of glycemic excursions based on the crosses of a short and long
moving average of the glucose profile, and implemented in version 3+ of
R package iglu. The accuracy of the algorithm was evaluated relative to
manual calculations using a five-fold cross-validation and compared to
other publicly available MAGE calculators, as listed in Table 2.</p>
<p><strong>Results</strong>: The newly developed algorithm had the
median error of 1.4% relative to manual calculations (iglu v4.1+). The
median errors of the six other approaches including AGATA, EasyGV,
cgmanalysis, naive iglu algorithm, rGV, and cgmquantify are 9.8%, 11.3%,
20.3%, 42.0%, 78.4%, and 78.1%, respectively.</p>
<p><strong>Conclusions</strong>: The newly developed algorithm
eliminates the need for tedious manual MAGE calculations and
approximates the manual derivation better than existing approaches.</p>
</div>
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>Glucose variability is increasingly regarded as a risk factor for
diabetes-related complications beyond HbA1c [1, 2]. The mean amplitude
of glycemic excursions (MAGE) is a commonly used measure of glucose
variability. As defined by Service et al. [3], MAGE is the arithmetic
mean of the amplitude (i.e. height) of glucose excursions that are
greater than the standard deviation of the glucose values. MAGE is
calculated manually by visually inspecting the glucose profiles.
However, this manual approach to calculating MAGE is error-prone and
impractical for large data sets of continuous glucose monitors (CGMs).
Thus, an automated algorithm for MAGE calculation that approximates the
manual reference is needed.</p>
<p>Several software programs for automated MAGE calculations have been
developed, and these implementations can be divided into two categories:
those that only return the numeric MAGE values, and those that
additionally provide a visual display of the calculations [4]. Examples
in the first category include the Excel®-based workbook EasyGV [5],
online GlyCulator2 [6], R package cgmanalysis [7], early versions of R
package iglu [8], and Python package cgmquantify [9]. Because these
software programs do not output a visual display of the performed
calculations, the user has no means to inspect the calculations and
confirm accuracy. Examples in the second category include programs
developed by Fritzsche [10] and Baghurst [11]. However, we found the
software developed by Fritzsche are not compatible with newer operating
systems (e.g., Windows 10) to allow importing of CGM data. Additionally,
Baghurst does not provide a downloadable implementation of his
algorithm. However, according to documentation for cgmanalysis [7] and
cgmquantify [9], these packages provide free implementations of
Baghurst’s algorithm, albeit they may not fully reflect the original
implementation.</p>
<p>The comparison of GlyCulator, EasyGV, Fritzsche, and Baghurst
algorithms demonstrates varying degrees of agreement across MAGE
algorithms [12]. While the aforementioned algorithms were compared to
each other, they were not compared with the manual reference
standard.</p>
<p>Thus, the objective of current study is to establish an approach of
calculating MAGE that is user-friendly and approximates well the results
obtained manually. Therefore, these goals are defined as follows.</p>
<ol style="list-style-type: decimal">
<li><p>To computationally emulate the manual method in Service et
al. [3] with high accuracy based on the automated detection of peaks and
nadirs tailored specifically towards CGM data</p></li>
<li><p>To provide a freely-available implementation with a visual
display</p></li>
</ol>
<p>To evaluate accuracy, the newly developed algorithm was compared with
the manual derivations along with the other computational
approaches.</p>
</div>
<div class="section level2">
<h2 id="methods">Methods<a class="anchor" aria-label="anchor" href="#methods"></a>
</h2>
<p><em>CGM Data and Manual MAGE Calculation</em></p>
<p>Publicly-available CGM data were obtained from [13], from which 45
CGM traces were selected to represent a diverse set of patients (Type 1
diabetes, Type 2 diabetes, and those without diabetes), see Table 1.
Each CGM trace corresponds to one day of measurements (24 h), where a
day is defined from midnight to midnight as it is customary to calculate
MAGE daily. Manual MAGE calculations were performed on each of the 45
CGM traces following the original description of MAGE calculations by
Service et al. [3] by two of the authors, who were unaware of the
outcome of the proposed algorithm’s outputs.</p>
<p><strong>Table 1:</strong> Summary of the 45 CGM traces used for
manual calculations. The first three datasets have been obtained as
described in [13]. The last dataset is available within R package iglu
[8].</p>
<table style="width:83%;" class="table">
<colgroup>
<col width="16%">
<col width="16%">
<col width="16%">
<col width="16%">
<col width="16%">
</colgroup>
<thead><tr class="header">
<th align="center">Dataset</th>
<th align="center">Diabetes Type</th>
<th align="center">Age group</th>
<th align="center">Subject ID</th>
<th align="center">Number of days used (CGM traces)</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="center">Hall et al. (2018)</td>
<td align="center">None</td>
<td align="center">Adults (&gt;18)</td>
<td align="center">16 36-69-001</td>
<td align="center">5</td>
</tr>
<tr class="even">
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">16 36-69-026</td>
<td align="center">6</td>
</tr>
<tr class="odd">
<td align="center">Tsalikian et al. (2005)</td>
<td align="center">Type 1</td>
<td align="center">Children (10 - 18)</td>
<td align="center">2</td>
<td align="center">1</td>
</tr>
<tr class="even">
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">7</td>
<td align="center">2</td>
</tr>
<tr class="odd">
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">8</td>
<td align="center">1</td>
</tr>
<tr class="even">
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">11</td>
<td align="center">2</td>
</tr>
<tr class="odd">
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">15</td>
<td align="center">1</td>
</tr>
<tr class="even">
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">43</td>
<td align="center">1</td>
</tr>
<tr class="odd">
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">44</td>
<td align="center">1</td>
</tr>
<tr class="even">
<td align="center">Dubosson et al. (2005)</td>
<td align="center">Type 1</td>
<td align="center">Adults (&gt;18)</td>
<td align="center">1</td>
<td align="center">5</td>
</tr>
<tr class="odd">
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr class="even">
<td align="center">Broll et al. (2021)</td>
<td align="center">Type 2</td>
<td align="center">Adults (&gt;18)</td>
<td align="center">Subject 1</td>
<td align="center">1</td>
</tr>
<tr class="odd">
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">Subject 2</td>
<td align="center">5</td>
</tr>
<tr class="even">
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">Subject 3</td>
<td align="center">1</td>
</tr>
<tr class="odd">
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">Subject 4</td>
<td align="center">5</td>
</tr>
<tr class="even">
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">Subject 5</td>
<td align="center">6</td>
</tr>
</tbody>
</table>
<p><em>Existing MAGE Calculators</em></p>
<p>We benchmarked the proposed algorithm against a variety of open and
closed-source tools. To the best of our knowledge, the list in Table 2
comprises a relatively exhaustive list of existing packages to compute
MAGE on CGM data as of May 15, 2024.</p>
<p><strong>Table 2:</strong> An exhaustive list (to the best of our
knowledge) of existing packages and algorithms to compute MAGE as of May
15, 2024. We also specify the version and release date if we benchmark
the proposed MAGE algorithm against it, or the reason we were unable
to.</p>
<table style="width:96%;" class="table">
<colgroup>
<col width="26%">
<col width="17%">
<col width="18%">
<col width="17%">
<col width="17%">
</colgroup>
<thead><tr class="header">
<th align="center">Tool or Algorithm Name</th>
<th align="center">Has MAGE</th>
<th align="center">Benchmarked?</th>
<th align="center">Version Used</th>
<th align="center">Release Date</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="center">iglu::mage_ma (Proposed)</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">iglu v4.1</td>
<td align="center">Present</td>
</tr>
<tr class="even">
<td align="center">iglu::mage_naive</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">iglu v2.0</td>
<td align="center">Feb 27, 2020</td>
</tr>
<tr class="odd">
<td align="center">EasyGV [5]</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">
<p>EasyGV v9.0</p>
<p>(The download link for Version 10 is broken &amp; only downloads
Version 9.0)</p>
</td>
<td align="center">Oct 6, 2020</td>
</tr>
<tr class="even">
<td align="center">cgmanalysis [7]</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">cgmanalysis v2.7.7</td>
<td align="center">Nov 20, 2023</td>
</tr>
<tr class="odd">
<td align="center">rGV [18]</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">rGV v0.0.4</td>
<td align="center">Jan 17, 2023</td>
</tr>
<tr class="even">
<td align="center">cgmquantify [9]</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Commit: d4a788c</td>
<td align="center">Feb 8, 2021</td>
</tr>
<tr class="odd">
<td align="center">AGATA [19]</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">agata -2.1.1.zip</td>
<td align="center">Jan 27, 2023</td>
</tr>
<tr class="even">
<td align="center">CGDA [20]</td>
<td align="center">Yes</td>
<td align="center">No: skips computing MAGE for some CGM traces without
warning</td>
<td align="center">N/A</td>
<td align="center">N/A</td>
</tr>
<tr class="odd">
<td align="center">CGM Shiny [21]</td>
<td align="center">Yes</td>
<td align="center">No: Unable to load CSV files with sensor data</td>
<td align="center">N/A</td>
<td align="center">N/A</td>
</tr>
<tr class="even">
<td align="center">“Group of Signs” Method [22]</td>
<td align="center">Yes</td>
<td align="center">No: no open-source code provided.</td>
<td align="center">N/A</td>
<td align="center">N/A</td>
</tr>
<tr class="odd">
<td align="center">“Spline Interpolation” Method [23]</td>
<td align="center">Yes</td>
<td align="center">No: no open-source code provided. Coded from scratch
as per paper</td>
<td align="center">N/A</td>
<td align="center">N/A</td>
</tr>
<tr class="even">
<td align="center">“Linear Interpolation” Method [24]</td>
<td align="center">Yes</td>
<td align="center">No: no open-source code provided. Coded from scratch
as per paper</td>
<td align="center">N/A</td>
<td align="center">N/A</td>
</tr>
<tr class="odd">
<td align="center">GVAP Tool [25]</td>
<td align="center">Yes</td>
<td align="center">No: Requires CGM traces to have &gt;100 points, which
fails to work with some manual traces with large gaps</td>
<td align="center">N/A</td>
<td align="center">N/A</td>
</tr>
<tr class="even">
<td align="center">CGMTSA [26]</td>
<td align="center">Yes</td>
<td align="center">No: Cannot process some CGM traces when less than 24
hours worth of data</td>
<td align="center">N/A</td>
<td align="center">N/A</td>
</tr>
<tr class="odd">
<td align="center">CGMStatsAnalyser [27]</td>
<td align="center">Yes</td>
<td align="center">No: Unable to load CSV files with sensor data</td>
<td align="center">N/A</td>
<td align="center">N/A</td>
</tr>
<tr class="even">
<td align="center">Fritzche [10]</td>
<td align="center">Yes</td>
<td align="center">No: Software not compatible with modern operating
systems (Windows 10 / MacOS)</td>
<td align="center">N/A</td>
<td align="center">N/A</td>
</tr>
<tr class="odd">
<td align="center">
<p>GlyCulator2 [6]</p>
<p>GlyCulator3 [28]</p>
</td>
<td align="center">Yes</td>
<td align="center">No: program requires input of exact # of glucose
values which fails to work with variable- length MAGE computation or CGM
traces with gaps</td>
<td align="center">N/A</td>
<td align="center">N/A</td>
</tr>
<tr class="even">
<td align="center">MAGECAA v1.0 [4]</td>
<td align="center">Yes</td>
<td align="center">No: Closed -source - copy requested from the
author</td>
<td align="center">N/A</td>
<td align="center">N/A</td>
</tr>
<tr class="odd">
<td align="center">Baghurst [11]</td>
<td align="center">Yes</td>
<td align="center">No: Closed source. Unable to acquire a copy.</td>
<td align="center">N/A</td>
<td align="center">N/A</td>
</tr>
<tr class="even">
<td align="center">CGM-Guide [29]</td>
<td align="center">Yes</td>
<td align="center">No: Closed source. Unable to acquire a copy.</td>
<td align="center">N/A</td>
<td align="center">N/A</td>
</tr>
<tr class="odd">
<td align="center">Tidepool [30]</td>
<td align="center">No</td>
<td align="center">N/A</td>
<td align="center">N/A</td>
<td align="center">N/A</td>
</tr>
<tr class="even">
<td align="center">GLU [31]</td>
<td align="center">No</td>
<td align="center">N/A</td>
<td align="center">N/A</td>
<td align="center">N/A</td>
</tr>
<tr class="odd">
<td align="center">CGMAnalyzer [32]</td>
<td align="center">No</td>
<td align="center">N/A</td>
<td align="center">N/A</td>
<td align="center">N/A</td>
</tr>
</tbody>
</table>
<p><em>The Algorithm</em></p>
<p>The original MAGE description in Service et al. [3] requires (i)
identification of turning points (e.g., peaks and nadirs) for
calculation of glucose excursions; (ii) filtering those turning points
to only keep relevant glucose excursions and calculating the mean of
those excursion amplitudes (i.e., heights).</p>
<p>To the best of our knowledge, our implementations for both parts (i)
and (ii) are unique.</p>
<ol style="list-style-type: lower-roman">
<li>
<p><strong>Identification of peaks and nadirs.</strong> The proposed
algorithm uses the crosses of a short and long moving average to
identify time intervals where a peak or nadir may exist. Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
be the window size for the short moving average and 𝛽 be the window size
for the long moving average, such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>&lt;</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha &lt; \beta</annotation></semantics></math>.
Since the shorter moving average is more affected by local variation in
the glucose values than the longer moving average, a peak or nadir
(i.e., a turning point,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mi>t</mi><mi>p</mi></mrow><mi>i</mi></msub><annotation encoding="application/x-tex">{tp}_i</annotation></semantics></math>)
must exist on the intervals that are bounded by the crosses of the two
moving averages
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">cp_i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><msub><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">cp_{i+1}</annotation></semantics></math>
as demonstrated in Figure 1, with the exception of “whiplash”. (Note:
the first and last glucose values are always treated as crossing points
[Appendix: <a href="#why-are-the-first-and-last-data-points-always-treated-as-crossing-points">Why
are the first and last data points always treated as crossing
points?</a>].) To solve the issue of “whiplash”, where the true
peak/nadir falls outside the interval bounded by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">cp_i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><msub><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">cp_{i+1}</annotation></semantics></math>
for back-to-back sinusoidal excursions [Appendix: <a href="#what-is-whiplash">What is whiplash?</a>], we make the assumption
that peaks and nadirs alternate (peak, nadir, peak, nadir, etc.) or vice
versa and calculate subsequent peaks or nadirs sequentially as the
maximum or minimum glucose value, respectively, between the index of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><msub><mi>p</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">tp_{i-1}</annotation></semantics></math>
(left boundary, exclusive) and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><msub><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">cp_{i+1}</annotation></semantics></math>
(right boundary, inclusive) for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i=2</annotation></semantics></math>.
The left boundary is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">cp_{i}</annotation></semantics></math>
for the base case of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=1</annotation></semantics></math>.</p>
<p>A distinct advantage of using moving averages to identify the turning
points is that they inherently smooth out local fluctuations and noise
within larger trends in a glucose profile. The amount of smoothing can
be tuned by varying window size parameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>.
By default, the algorithm uses
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">\alpha = 5</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>=</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">\beta = 32</annotation></semantics></math>
as these values maximized the algorithm’s accuracy on the manual MAGE
calculations, where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>1</mn><mo>,</mo><mn>7</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\alpha \in [1, 7]</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>16</mn><mo>,</mo><mn>38</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\beta \in [16, 38]</annotation></semantics></math>.</p>
</li>
<li>
<p><strong>Eliminating Excursions and Calculation of Mean
Amplitudes.</strong> An excursion is defined by three turning points
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><msub><mi>p</mi><mi>i</mi></msub><mo>,</mo><mi>t</mi><msub><mi>p</mi><mi>j</mi></msub><mo>,</mo><mi>t</mi><msub><mi>p</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> s.t. </mtext><mspace width="0.333em"></mspace></mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">E_{i,j,k}=(tp_i, tp_j, tp_k) \text{ s.t. } i &lt; j &lt; k</annotation></semantics></math>
, where the amplitude of the excursion is calculated as follows:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>j</mi><mo>,</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">|</mo><mi>t</mi><msub><mi>p</mi><mi>j</mi></msub><mo>−</mo><mi>t</mi><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">|</mo></mrow></mrow><annotation encoding="application/x-tex">a(j, i) = |tp_j - tp_i|</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">|</mo><msub><mi>E</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub><mo stretchy="true" form="postfix">|</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">|</mo><msub><mi>E</mi><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi></mrow></msub><mo stretchy="true" form="postfix">|</mo></mrow><mo>,</mo><mrow><mo stretchy="true" form="prefix">|</mo><msub><mi>E</mi><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow></msub><mo stretchy="true" form="postfix">|</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>j</mi><mo>,</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">|E_{i,j,k}| = (|E_{left}|,|E_{right}|)=(a(j, i), a(k, j))</annotation></semantics></math>.
An “acceptable” excursion, as defined by Service et al. [3], requires
the amplitudes of both the left-side and right-side half-excursions to
exceed the standard deviation of the entire CGM trace. Computationally,
we devised the procedure below to calculate acceptable excursions, given
a set of alternating turning points. To prevent double counting
excursions, only ascending (MAGE+) or descending (MAGE–) half-excursion
amplitudes are averaged (i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">|</mo><msub><mi>E</mi><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi></mrow></msub><mo stretchy="true" form="postfix">|</mo></mrow><annotation encoding="application/x-tex">|E_{left}|</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">|</mo><msub><mi>E</mi><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow></msub><mo stretchy="true" form="postfix">|</mo></mrow><annotation encoding="application/x-tex">|E_{right}|</annotation></semantics></math>,
respectively), where ascending means
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><msub><mi>p</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">tp_j</annotation></semantics></math>
is a peak and vice versa. When excursions are symmetric, MAGE+ = MAGE–,
however in general they may disagree [11]. By default, our
implementation follows the description in Service et al. [3], and
returns MAGE+ or MAGE– depending on which type of excursion first
crosses the one SD threshold; however, the user can specify either if
desired.</p>
<p><em>Procedure:</em> Starting from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>j</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i=1, j=2</annotation></semantics></math>
(note: R is 1-based), check whether the amplitude exceeds the one
standard deviation threshold,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>j</mi><mo>,</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>&gt;</mo><mi>s</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">a(j, i) = a(2, 1) &gt; sd</annotation></semantics></math>.
If false, the algorithm will calculate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>max</mo><mspace width="0.278em"></mspace><mo stretchy="false" form="prefix">{</mo><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>3</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="0.278em"></mspace><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>3</mn><mo>,</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="false" form="postfix">}</mo><mo>&gt;</mo><mi>s</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">\max\; \{a(3,1), \; a(3,2)\} &gt; sd</annotation></semantics></math>
and so on until a large enough amplitude is found or the CGM trace ends.
Note: we use the maximum to enable “accumulation”, an optimization that
allows an earlier larger half-excursion to absorb a later smaller
half-excursion. Once an acceptable left-side half-excursion is found,
the boundaries
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
are recorded and the same procedure is used to find an acceptable
right-side excursion, where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
is updated if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo>,</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>&gt;</mo><mo>=</mo><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>j</mi><mo>,</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a(k, i) &gt;= a(j, i)</annotation></semantics></math>.
We record
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>E</mi><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">E_{left}</annotation></semantics></math>
once
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow></msub><mo>&gt;</mo><mi>s</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">E_{right} &gt; sd</annotation></semantics></math>
or the CGM trace ends.</p>
</li>
</ol>
<p><em>Handling Gaps</em></p>
<p>The algorithm outlined above assumes that the input CGM trace should
be treated contiguously, with MAGE calculated over the entire trace and
turning points alternate (peak, nadir, peak, nadir, etc.) or vice versa.
However, this can lead to suboptimal results if large gaps are present
in the trace. While small gaps can be interpolated before MAGE
calculation (starting in iglu v3.3.0), CGM values separated by large
gaps should be treated as separate segments, with MAGE calculated on
each segment independently. By default, MAGE released in iglu v3.5.1+
segments the CGM trace by gaps larger than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>_</mi><mi>g</mi><mi>a</mi><mi>p</mi><mo>=</mo><mn>180</mn><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> minutes</mtext></mrow></mrow><annotation encoding="application/x-tex">max\_gap=180 \text{ minutes}</annotation></semantics></math>
and calculates MAGE via the above algorithm on each segment [Appendix:
[Why set a default of 180 minutes for max_gap?]]. The user can then
return the MAGE values for each segment
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>A</mi><mi>G</mi><msub><mi>E</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">MAGE_i</annotation></semantics></math>)
or a one-number summary for the variability of the entire CGM trace
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>A</mi><mi>G</mi><msub><mi>E</mi><mrow><mi>o</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>l</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">MAGE_{overall}</annotation></semantics></math>).
MAGE for the entire trace is reported as an average of the segment MAGE
values, weighted by segment length
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>A</mi><mi>G</mi><msub><mi>E</mi><mrow><mi>o</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>l</mi><mi>l</mi></mrow></msub><mo>=</mo><mi>Σ</mi><mfrac><msub><mi>n</mi><mi>i</mi></msub><mi>N</mi></mfrac><mi>M</mi><mi>A</mi><mi>G</mi><msub><mi>E</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">MAGE_{overall} = \Sigma \frac{n_i}{N}MAGE_i</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mi>i</mi></msub><annotation encoding="application/x-tex">n_i</annotation></semantics></math>
is the length of segment
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mi>Σ</mi><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">N = \Sigma n_i</annotation></semantics></math>).
The plot displays segments with a solid, black vertical line for the
left-boundary and a dashed, black vertical line for the right
boundary.</p>
<p><a name="example_code"></a><br><em>Implementation</em><br>
The newly developed algorithm for MAGE calculation can be found from
version 3 onward in R package iglu [17] as well as the accompanying GUI
via Shiny App [8] - both are free and open-source. Implementation in a
script-based programming language like R allows the creation of
reproducible scripts for all data processing and MAGE calculation steps,
and the availability of a point-and-click GUI meets the needs of
researchers with limited programming experience. By default, the
algorithm uses
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">\alpha = 5</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>=</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">\beta = 32</annotation></semantics></math>,
however these choices can be adjusted by the user.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># load package and example data</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://irinagain.github.io/iglu/">iglu</a></span><span class="op">)</span></span>
<span></span>
<span><span class="co"># mage calculation using default parameters</span></span>
<span><span class="fu"><a href="../reference/mage.html">mage</a></span><span class="op">(</span><span class="va">example_data_5_subject</span><span class="op">)</span></span>
<span><span class="co">#&gt; <span style="color: #949494;"># A tibble: 5 × 2</span></span></span>
<span><span class="co">#&gt; <span style="color: #949494;"># Rowwise: </span></span></span>
<span><span class="co">#&gt;   id         MAGE</span></span>
<span><span class="co">#&gt;   <span style="color: #949494; font-style: italic;">&lt;fct&gt;</span>     <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span></span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">1</span> Subject 1  72.4</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">2</span> Subject 2 118. </span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">3</span> Subject 3 116. </span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">4</span> Subject 4  70.9</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">5</span> Subject 5 142.</span></span>
<span></span>
<span><span class="co"># Adjust default window sizes in mage calculation</span></span>
<span><span class="fu"><a href="../reference/mage.html">mage</a></span><span class="op">(</span><span class="va">example_data_5_subject</span>, short_ma <span class="op">=</span> <span class="fl">3</span>, long_ma <span class="op">=</span> <span class="fl">30</span><span class="op">)</span></span>
<span><span class="co">#&gt; <span style="color: #949494;"># A tibble: 5 × 2</span></span></span>
<span><span class="co">#&gt; <span style="color: #949494;"># Rowwise: </span></span></span>
<span><span class="co">#&gt;   id         MAGE</span></span>
<span><span class="co">#&gt;   <span style="color: #949494; font-style: italic;">&lt;fct&gt;</span>     <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span></span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">1</span> Subject 1  72.3</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">2</span> Subject 2 118. </span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">3</span> Subject 3 116. </span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">4</span> Subject 4  70.9</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">5</span> Subject 5 142.</span></span></code></pre></div>
<p>In addition to providing a numerical MAGE value, the software allows
the creation of glucose trace plots that highlight the selected peaks
and nadirs used for MAGE calculation.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># subset data to better see identified peaks and nadirs</span></span>
<span><span class="va">fig1data</span> <span class="op">&lt;-</span> <span class="va">example_data_1_subject</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">200</span>, <span class="op">]</span></span>
<span><span class="co"># plot using mage function with plot = TRUE and show_ma = TRUE </span></span>
<span><span class="fu"><a href="../reference/mage.html">mage</a></span><span class="op">(</span><span class="va">fig1data</span>, plot <span class="op">=</span> <span class="cn">TRUE</span>, show_ma <span class="op">=</span> <span class="cn">TRUE</span>, title <span class="op">=</span> <span class="st">"Glucose Trace - Subject 1"</span><span class="op">)</span></span></code></pre></div>
<p><img src="MAGE_files/figure-html/figure%201-1.png" width="672"></p>
<p><strong>Figure 1:</strong> Glucose trace of Subject 2 with Type 2
diabetes from Broll et al. [8], the solid green line is a short MA with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
= 5 and the solid orange line is a long MA with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>
= 32. The peaks and nadirs occur between the crosses of short and long
moving averages. By default, the algorithm calculates MAGE+ as in this
profile the first segment to exceed one SD threshold is ascending. The
provided graphical display in iglu software [17] automatically
highlights only those peaks (red) and nadirs (blue) that are used for
final calculation.</p>
<p>   </p>
<p>Additionally, the plot will highlight any gaps in the data due to
missing readings. If these gaps are shorter than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>_</mi><mi>g</mi><mi>a</mi><mi>p</mi><mo>=</mo><mn>180</mn></mrow><annotation encoding="application/x-tex">max\_gap = 180</annotation></semantics></math>,
they will be part of the same segment.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span></span>
<span><span class="co"># subset data to better show gaps</span></span>
<span><span class="va">fig2data</span> <span class="op">&lt;-</span> <span class="va">example_data_1_subject</span><span class="op">[</span><span class="fl">200</span><span class="op">:</span><span class="fl">400</span>, <span class="op">]</span></span>
<span><span class="co"># plot using mage function with plot = TRUE</span></span>
<span><span class="fu"><a href="../reference/mage.html">mage</a></span><span class="op">(</span><span class="va">fig2data</span>, plot <span class="op">=</span> <span class="cn">TRUE</span>, title <span class="op">=</span> <span class="st">"Glucose Trace with Gaps - Subject 1"</span><span class="op">)</span></span></code></pre></div>
<p><img src="MAGE_files/figure-html/figure%202-1.png" width="672"></p>
<p><strong>Figure 2</strong>. Glucose trace of Subject 5 with Type 2
diabetes from Broll et al. [8] with regions of missing glucose readings
automatically highlighted using iglu software [17].</p>
<p>   </p>
<p><em>Assessment of Accuracy</em><br>
The accuracy of the proposed algorithm was evaluated against 45 manual
calculations. For each CGM trace, the accuracy was measured as the
relative percent difference in the automatically calculated MAGE value
and the manual MAGE value, that is:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mo stretchy="true" form="prefix">|</mo><mi>M</mi><mi>A</mi><mi>G</mi><msub><mi>E</mi><mrow><mi>a</mi><mi>l</mi><mi>g</mi><mi>o</mi><mi>r</mi><mi>i</mi><mi>t</mi><mi>h</mi><mi>m</mi></mrow></msub><mo>−</mo><mi>M</mi><mi>A</mi><mi>G</mi><msub><mi>E</mi><mrow><mi>m</mi><mi>a</mi><mi>n</mi><mi>u</mi><mi>a</mi><mi>l</mi></mrow></msub><mo stretchy="true" form="postfix">|</mo></mrow><mrow><mi>M</mi><mi>A</mi><mi>G</mi><msub><mi>E</mi><mrow><mi>m</mi><mi>a</mi><mi>n</mi><mi>u</mi><mi>a</mi><mi>l</mi></mrow></msub></mrow></mfrac><mo>⋅</mo><mn>100</mn><mi>%</mi></mrow><annotation encoding="application/x-tex">\frac{|MAGE_{algorithm} - MAGE_{manual}|}{MAGE_{manual}}\cdot 100\%</annotation></semantics></math>
.</p>
<p>To find optimal combination of window sizes, we considered
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>1</mn><mo>,</mo><mn>7</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\alpha \in [1, 7]</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>16</mn><mo>,</mo><mn>38</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\beta \in [16, 38]</annotation></semantics></math>,
and recorded the mean errors across 45 CGM traces for each pair of
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>,</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha, \beta</annotation></semantics></math>)
values. The optimal
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>,</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha, \beta</annotation></semantics></math>)
pair was determined as the one that leads to the minimal in-sample
error. Since the obtained minimal error is a biased assessment of
accuracy as the optimal
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>,</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha, \beta</annotation></semantics></math>)
were selected based on the same 45 traces, five-fold cross-validation
was also performed to gain an unbiased assessment of accuracy. The 45
CGM traces were randomly split into five groups of nine samples each.
The best
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>,</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha, \beta</annotation></semantics></math>)
combination was then chosen using four out of the five groups, and used
to evaluate the accuracy on the remaining group. The best combination
was defined as the one that gave the lowest percent error compared to
manual calculations. This out-of-sample evaluation was performed on all
five groups.</p>
<p>The accuracy of EasyGV [5], cgmanalysis [7], cgmquantify [9], rGV,
AGATA, and the MAGE algorithm implemented in the earlier version of iglu
[8] was also determined against the manual reference derivation. The
latter is a naive simplification of original MAGE definition, as it
calculates MAGE as the mean of absolute differences between glucose
values and the glucose mean that are larger than one standard deviations
(and thus does not attempt to explicitly identify peaks and nadirs). We
use iglu_ma to denote the proposed algorithm based on moving averages,
and iglu_naive to denote the naive algorithm used in earlier versions of
the software. We were unable to evaluate GlyCulator2 [6] because the
software requires CGM trace to have at least 576 time points, and thus
returns NA when applied to 24-hour CGM data. We were also unable to
evaluate Fritzsche [10] as importing the CGM data into the provided user
interface on Windows 10 lead to errors.</p>
<p><em>Assessment of Parameter Frequency Robustness</em></p>
<p>We also test if the optimal long and short window parameters chosen
on the 5-minute CGM data - i.e.,
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mrow><mi>b</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub><mo>,</mo><msub><mi>β</mi><mrow><mi>b</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\alpha_{best}, \beta_{best}</annotation></semantics></math>)
- are robust to the frequency of the meter / CGM data (e.g., 1-, 5-,
10-, and 15-minute). To do this, we use the
<code><a href="../reference/CGMS2DayByDay.html">iglu::CGMS2DayByDay</a></code> function to change the raw data’s
frequency to 1-, 10-, and 15-minute intervals, and automatically imputes
glucose values for gaps less than 45 minutes. We then rerun the
hyperparameter tuning code to discover the best
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>,</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha, \beta</annotation></semantics></math>)
selected on the new data and report the mean, median, and IQR of errors.
Note that this is not a perfect comparison: information is lost when
downsampling the 5-minute CGM trace to 10- and 15-minutes but the manual
calculations compared against are performed on 5-minute data. Thus, we
expect to see a slightly degraded performance on the 10- and 15-minute
data simply due to this design limitation and not necessarily an
algorithm limitation.</p>
</div>
<div class="section level2">
<h2 id="results">Results<a class="anchor" aria-label="anchor" href="#results"></a>
</h2>
<p>The optimal choice of window sizes
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>,</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha, \beta</annotation></semantics></math>)
for the proposed algorithm on the 5-minute CGM data was determined to be
(5, 32) as this combination minimized the average error relative to 45
manual calculations. Figure 3 shows a heatmap of the percent average
error (across 45 traces) as a function of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>,
where the darkest regions represent the most favorable combinations of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>.
(Note: while there was a tie, we chose hyperparameters in the middle of
the dark region.) The minimum corresponds to a mean average error of
8.9% with a much smaller median percent error of 1.4% and [Q1, Q3] =
[0.5%, 7.1%]. As expected, the unbiased out-of-sample cross-validated
errors are slightly larger, but still relatively low: 9.1% mean with the
median of 10.0% and inter-quartile range of [9.4%, 11.8%].</p>
<p><img src="mage_figures/hyper-param-tuning.png" width="700px" height="400px"></p>
<p><strong>Figure 3.</strong> Heatmap of average errors over 45 CGM
traces of automatically calculated MAGE values via proposed algorithm
relative to manual MAGE values. The short moving average window size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>1</mn><mo>,</mo><mn>7</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\alpha \in [1, 7]</annotation></semantics></math>
and the long moving average window size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>16</mn><mo>,</mo><mn>38</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\beta \in [16, 38]</annotation></semantics></math>.
The darker regions correspond to smaller errors, with the minimal error
of % achieved at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">\alpha = 5</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>=</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">\beta = 32</annotation></semantics></math>.</p>
<p>   </p>
<p>Compared to the other available automated algorithms, the next best
results were achieved by EasyGV, which had an average error of 23.4%,
the median error of 11.3% and the IQR of [6.0%, 22.3%]. In constrast,
cgmanalysis, iglu_naive, and cgmquantify all had significantly higher
errors, with median errors (and interquartile range) of 20.3% [8.6%,
32.1%], 42.0% [32.6%, 48.3%], and 78.4% [30.8%, 131.9%], respectively.
Figure 4 shows boxplots of relative errors of all algorithms on 45 CGM
traces. Figure 5 and Table 3 show a correlation matrix of all algorithms
on the 45 CGM traces. (Note: see the “Important Notes on rGV” in the
Discussion below.)</p>
<p><img src="mage_figures/boxplot-of-errors2.png" width="700px" height="400px"></p>
<p>   </p>
<p><strong>Table 3.</strong> Correlation matrix of various MAGE
calculators’ outputs on the 45 CGM traces.</p>
<table class="table">
<colgroup>
<col width="14%">
<col width="13%">
<col width="8%">
<col width="11%">
<col width="14%">
<col width="8%">
<col width="10%">
<col width="4%">
<col width="14%">
</colgroup>
<thead><tr class="header">
<th align="left"></th>
<th align="right">Manual Calc</th>
<th align="right">Iglu_ma</th>
<th align="right">Iglu_naive</th>
<th align="right">CGM_Analysis</th>
<th align="right">Easy_GV</th>
<th align="right">agata_err</th>
<th align="right">rGV</th>
<th align="right">CGM_Quantify</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">Manual Calc</td>
<td align="right">1.00</td>
<td align="right">0.93</td>
<td align="right">0.90</td>
<td align="right">0.82</td>
<td align="right">0.91</td>
<td align="right">0.92</td>
<td align="right">0</td>
<td align="right">0.66</td>
</tr>
<tr class="even">
<td align="left">Iglu_ma</td>
<td align="right">0.93</td>
<td align="right">1.00</td>
<td align="right">0.96</td>
<td align="right">0.85</td>
<td align="right">0.98</td>
<td align="right">0.92</td>
<td align="right">0</td>
<td align="right">0.70</td>
</tr>
<tr class="odd">
<td align="left">Iglu_naive</td>
<td align="right">0.90</td>
<td align="right">0.96</td>
<td align="right">1.00</td>
<td align="right">0.92</td>
<td align="right">0.98</td>
<td align="right">0.88</td>
<td align="right">0</td>
<td align="right">0.69</td>
</tr>
<tr class="even">
<td align="left">CGM_Analysis</td>
<td align="right">0.82</td>
<td align="right">0.85</td>
<td align="right">0.92</td>
<td align="right">1.00</td>
<td align="right">0.87</td>
<td align="right">0.80</td>
<td align="right">0</td>
<td align="right">0.66</td>
</tr>
<tr class="odd">
<td align="left">Easy_GV</td>
<td align="right">0.91</td>
<td align="right">0.98</td>
<td align="right">0.98</td>
<td align="right">0.87</td>
<td align="right">1.00</td>
<td align="right">0.89</td>
<td align="right">0</td>
<td align="right">0.66</td>
</tr>
<tr class="even">
<td align="left">agata_err</td>
<td align="right">0.92</td>
<td align="right">0.92</td>
<td align="right">0.88</td>
<td align="right">0.80</td>
<td align="right">0.89</td>
<td align="right">1.00</td>
<td align="right">0</td>
<td align="right">0.66</td>
</tr>
<tr class="odd">
<td align="left">rGV</td>
<td align="right">0.00</td>
<td align="right">0.00</td>
<td align="right">0.00</td>
<td align="right">0.00</td>
<td align="right">0.00</td>
<td align="right">0.00</td>
<td align="right">1</td>
<td align="right">0.00</td>
</tr>
<tr class="even">
<td align="left">CGM_Quantify</td>
<td align="right">0.66</td>
<td align="right">0.70</td>
<td align="right">0.69</td>
<td align="right">0.66</td>
<td align="right">0.66</td>
<td align="right">0.66</td>
<td align="right">0</td>
<td align="right">1.00</td>
</tr>
</tbody>
</table>
<p>   </p>
<p><strong>Figure 4.</strong> Comparison of relative errors of different
automatic algorithms for MAGE calculation relative to manual MAGE values
on 45 CGM traces. The proposed method is implemented as ma (moving
average) algorithm in R package iglu [17]; best corresponds to the
errors with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">\alpha = 5</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>=</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">\beta = 32</annotation></semantics></math>;
cv corresponds to the out-of-sample errors based on 5-
fold-cross-validation for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>,</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha, \beta</annotation></semantics></math>.</p>
<p><img src="mage_figures/correlation_matrix.png" width="700px" height="400px"></p>
<p><strong>Figure 5.</strong> Heatmap of correlation matrix of various
MAGE calculators’ outputs on the 45 CGM traces.</p>
<p>   </p>
<p><strong>Table 4.</strong> Correlation matrix of various MAGE
calculators’ outputs on the 45 CGM traces and the mean and standard
deviations of the 45 CGM traces.</p>
<table class="table">
<thead><tr class="header">
<th align="left"></th>
<th align="right">mean</th>
<th align="right">sd</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">Manual Calc</td>
<td align="right">0.68</td>
<td align="right">0.88</td>
</tr>
<tr class="even">
<td align="left">Iglu_ma</td>
<td align="right">0.70</td>
<td align="right">0.93</td>
</tr>
<tr class="odd">
<td align="left">Iglu_naive</td>
<td align="right">0.67</td>
<td align="right">0.98</td>
</tr>
<tr class="even">
<td align="left">CGM_Analysis</td>
<td align="right">0.61</td>
<td align="right">0.94</td>
</tr>
<tr class="odd">
<td align="left">Easy_GV</td>
<td align="right">0.66</td>
<td align="right">0.95</td>
</tr>
<tr class="even">
<td align="left">agata_err</td>
<td align="right">0.72</td>
<td align="right">0.86</td>
</tr>
<tr class="odd">
<td align="left">rGV</td>
<td align="right">0.00</td>
<td align="right">0.00</td>
</tr>
<tr class="even">
<td align="left">CGM_Quantify</td>
<td align="right">0.90</td>
<td align="right">0.64</td>
</tr>
<tr class="odd">
<td align="left">mean</td>
<td align="right">1.00</td>
<td align="right">0.66</td>
</tr>
<tr class="even">
<td align="left">sd</td>
<td align="right">0.66</td>
<td align="right">1.00</td>
</tr>
</tbody>
</table>
<p>   </p>
<p>For the proposed algorithm, both in-sample errors with the best
choice of window sizes
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>,</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha, \beta</annotation></semantics></math>)
and out-of-sample cross-validated errors are displayed. The
corresponding numerical summaries are summarized in Table 2.</p>
<p>   </p>
<p><strong>Table 5:</strong> Numerical summaries of relative errors of
automatic MAGE calculators on 45 CGM traces compared to manual
calculations. The proposed method is implemented as ma (moving average)
algorithm in R package iglu [17]; best corresponds to the errors with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
= 5,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>
= 32; cv corresponds to the out-of-sample errors based on
5-fold-cross-validation for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>.</p>
<table class="table">
<thead><tr class="header">
<th align="center">Algorithm</th>
<th align="center">Mean</th>
<th align="center">Median</th>
<th align="center">IQR</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="center">iglu (ma, best)</td>
<td align="center">8.9%</td>
<td align="center">1.4%</td>
<td align="center">[0.5%, 7.1%]</td>
</tr>
<tr class="even">
<td align="center">iglu (ma, cv)</td>
<td align="center">9.1%</td>
<td align="center">10.0%</td>
<td align="center">[9.4%, 11.8%]</td>
</tr>
<tr class="odd">
<td align="center">iglu (naive)</td>
<td align="center">39.0%</td>
<td align="center">42.0%</td>
<td align="center">[32.6%, 48.3%]</td>
</tr>
<tr class="even">
<td align="center">EasyGV</td>
<td align="center">23.4%</td>
<td align="center">11.3%</td>
<td align="center">[6.0%, 22.3%]</td>
</tr>
<tr class="odd">
<td align="center">cgmanalysis</td>
<td align="center">23.9%</td>
<td align="center">20.3%</td>
<td align="center">[8.6%, 32.1%]</td>
</tr>
<tr class="even">
<td align="center">cgmquantify</td>
<td align="center">91.9%</td>
<td align="center">78.4%</td>
<td align="center">[30.8%, 131.9%]</td>
</tr>
<tr class="odd">
<td align="center">rGV</td>
<td align="center">74.7%</td>
<td align="center">78.1%</td>
<td align="center">[64.9%, 86.7%]</td>
</tr>
<tr class="even">
<td align="center">AGATA</td>
<td align="center">16.7%</td>
<td align="center">9.8%</td>
<td align="center">[4.4%, 26.3%]</td>
</tr>
</tbody>
</table>
<p><strong>Table 6:</strong> Numerical summaries of relative errors of
the proposed MAGE algorithm on 45 CGM traces compared to manual
calculations at varying frequencies of the underlying data. The
relatively constant mean error rate demonstrates the proposed method and
selected hyperparameters
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
= 5,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>
= 32) are robust to the frequency of the meter.</p>
<table class="table">
<thead><tr class="header">
<th align="center">CGM Frequency</th>
<th align="center">Mean</th>
<th align="center">Median</th>
<th align="center">IQR</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="center">1-min</td>
<td align="center">6.5%</td>
<td align="center">0.6%</td>
<td align="center">[0.3%, 3.6%]</td>
</tr>
<tr class="even">
<td align="center">5-min</td>
<td align="center">8.9%</td>
<td align="center">1.4%</td>
<td align="center">[0.5%, 7.1%]</td>
</tr>
<tr class="odd">
<td align="center">10-min</td>
<td align="center">9.7%</td>
<td align="center">2.5%</td>
<td align="center">[1.2%, 8.4%]</td>
</tr>
<tr class="even">
<td align="center">15-min</td>
<td align="center">10.7%</td>
<td align="center">5.3%</td>
<td align="center">[2.1%, 9.0%]</td>
</tr>
</tbody>
</table>
<p>   </p>
</div>
<div class="section level2">
<h2 id="discussion">Discussion<a class="anchor" aria-label="anchor" href="#discussion"></a>
</h2>
<p>There are several software programs for automatic MAGE calculation,
however, they show varying agreement [12]. In the current study, a new
automated algorithm for MAGE was developed based on moving averages
which demonstrated the least amount of error relative to manual
reference when compared to other automated algorithms.</p>
<p>The newly developed algorithm approximated the manual results better
than EasyGV, cgmanalysis, iglu_naive, and cgmquantify. The largest
discrepancy was noted for cgmanalysis and cgmquantify both of which
implemented Baghurst’s algorithm [11]. It is unclear whether the
deviation from manual reference is due to the underlying algorithm or
the specific of implementations of the algorithm. The differences in
accuracy among the MAGE algorithms points to the necessity of a visual
display of the underlying calculations with identified peaks and nadirs.
While such visual display is implemented for the proposed MAGE algorithm
in version 3 of R package iglu [17], this functionality is absent from
EasyGV, cgmanalysis, and cgmquantify, making it more difficult for the
user to verify the accuracy.</p>
<p>The correlation between our proposed algorithm (with Service
definition) and manual calculations per Service is 0.93 when compared
across the same 45 CGM traces. This is the largest correlation value
across the implementations we have compared (0.92 for AGATA, 0.91 for
EasyGV, 0.90 for older iglu MAGE algorithm, 0.82 for CGManalysis and
0.66 for CGMQuantify), which is consistent with our proposed approach
showing the lowest error rate relative to manual calculations. When
comparing correlations between our approach and existing methods, we
find correlation of 0.98 with EasyGV, 0.96 with older iglu MAGE
algorithm, 0.92 with AGATA, 0.85 with CGManalysis and 0.7 with
CGMquantify.</p>
<p>As can be seen in Table 4, there is a relatively high correlation
between MAGE and standard deviation of the CGM trace. This has been
noted before [33] and has led some to question the importance of using
MAGE over the simpler standard deviation. Nevertheless, further research
is needed to see if MAGE is better correlated with clinical outcomes
(e.g., morbidity or mortality) than the simple standard deviation.</p>
<p>A major challenge for any automated MAGE algorithm is separation of
true peaks and nadirs in a larger trend from the smaller glucose
fluctuations. A particular advantage of the proposed algorithm is the
use of moving averages which inherently smooth out local fluctuations
within a larger trend. The amount of smoothing can be tuned by varying
the window sizes of the short and long moving averages, and we found
that the algorithm is quite robust to the choice of window sizes, with
high accuracy in a large range (Figure 3). Additionally, the proposed
optimal short and long moving averages are robust to the frequency of
the CGM meter, as shown by the similar mean errors of the MAGE algorithm
despite the meter frequency in Table 4. One disadvantage is that the
moving average is a lagging indicator, and thus is undefined in the
beginning of the time period (e.g., a moving average of window size 20
is undefined for the first 19 time points). This could skew the
calculations of MAGE if the first times points contain a lot of
variation in subject’s glucose levels. To adjust for this, the algorithm
replaces the undefined moving average values at the first time points
with the first calculated moving average value (e.g., a moving average
of window size 20 will be first calculated at 20th time point, and that
same value will be assigned to the first 19 time point to be later used
in determining the crosses of short and long moving averages). This
adjustment can be seen for the long moving average in Figure 1, where
its value is flat for the first 32 points. Given the high accuracy of
the proposed algorithm compared to manual calculations, this adjustment
is adequate, however it is possible that it may not be adequate for some
CGM profiles. In practice, we recommend to inspect the visual display of
MAGE calculations provided by iglu [17] as in Figures 1 and 2 for
additional accuracy validation. Another challenge for MAGE calculations
is the presence of asymmetric excursions. To prevent double counting,
typically only ascending (MAGE+) or descending (MAGE–) excursion
amplitudes are averaged. When excursions are symmetric, MAGE+ = MAGE–,
and the accuracy is not affected irrespective of the choice of
direction. However, when excursions are asymmetric, the direction
matters as the two disagree. By default, our algorithm follows the
description in Service et al. [3], and calculates MAGE+ or MAGE–
depending on which type of excursion first crosses the one SD threshold.
The same decision is made in [12]. However, Baghurst [11] argues that it
is more appropriate to use
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>A</mi><mi>G</mi><msub><mi>E</mi><mrow><mi>a</mi><mi>v</mi><mi>g</mi></mrow></msub><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mi>M</mi><mi>A</mi><mi>G</mi><msub><mi>E</mi><mrow><mi>p</mi><mi>l</mi><mi>u</mi><mi>s</mi></mrow></msub><mo>+</mo><mi>M</mi><mi>A</mi><mi>G</mi><msub><mi>E</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>u</mi><mi>s</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">MAGE_{avg} = \frac{1}{2}(MAGE_{plus}+MAGE_{minus})</annotation></semantics></math>.
Our implementation allows the user to change the default settings, and
explicitly calculate MAGE+, MAGE–, MAGEavg, or MAGEmax, which makes our
algorithm’s implementation more flexible compared to existing MAGE
software.</p>
<div class="section level4">
<h4 id="important-notes-on-rgv-and-cgmquantify">Important Notes on rGV and cgmquantify<a class="anchor" aria-label="anchor" href="#important-notes-on-rgv-and-cgmquantify"></a>
</h4>
<p>As seen in Figure 4 and Table 3 above, the errors for rGV and
cgmquantify are quite high and much different than the other
calculators. After further analysis, we believe the following reasons
explain the high errors.</p>
<ol style="list-style-type: decimal">
<li>The MAGE function in rGV outputs 20 regardless of the input data -
this behavior is reproducible even with the example given in the rGV
function.</li>
<li>cgmquantify may incorrectly index a dataframe during the mage
computation, as identified in <a href="https://github.com/brinnaebent/cgmquantify/issues/10" class="external-link uri">https://github.com/brinnaebent/cgmquantify/issues/10</a>.</li>
</ol>
</div>
</div>
<div class="section level2">
<h2 id="conclusion">Conclusion<a class="anchor" aria-label="anchor" href="#conclusion"></a>
</h2>
<p>We present a new algorithm for MAGE calculation that significantly
outperforms existing algorithms. The implementation of this algorithm is
free and open-source, it is available in the R package iglu version 3
[17] as well as in the accompanying GUI via Shiny App at <a href="https://irinagain.shinyapps.io/shiny_iglu/" class="external-link uri">https://irinagain.shinyapps.io/shiny_iglu/</a>. Furthermore,
the visual displays of the CGM traces, exact values for manual MAGE and
the code to reproduce all analyses, along with instructions on how to
download each CGM trace, are publicly available at <a href="https://github.com/Nathaniel-Fernandes/mage_algorithm_data" class="external-link uri">https://github.com/Nathaniel-Fernandes/mage_algorithm_data</a>.
The public nature of CGM traces, manual MAGE values, and the algorithm
allow additional validation of presented results by a community at
large.</p>
<p><strong>Funding Sources</strong>: NSF CAREER Award DMS-2044823 to
IG</p>
<p><strong>Acknowledgements</strong>: The source of subset of the data
is the T1D Exchange, but the analyses, content and conclusions presented
herein are solely the responsibility of the authors and have not been
reviewed or approved by the T1D Exchange.</p>
<p><strong>Disclosures</strong>: None</p>
</div>
<div class="section level2">
<h2 id="appendix">Appendix<a class="anchor" aria-label="anchor" href="#appendix"></a>
</h2>
<div class="section level5">
<h5 id="why-are-the-first-and-last-data-points-always-treated-as-crossing-points">Why are the first and last data points always treated as crossing
points?<a class="anchor" aria-label="anchor" href="#why-are-the-first-and-last-data-points-always-treated-as-crossing-points"></a>
</h5>
<p>If we didn’t, we would throw away at the beginning or end of CGM
trace because the MAGE algorithm calculates MAGE between the first and
last crossing point. For example, assume a CGM trace of 100 values with
the first and last crossing point at index 20 and 80, respectively. The
turning points are looked for between index 20 and 80, which throws out
the beginning and end. Thus, we automatically record the first and last
points in the CGM trace as crossing points.</p>
</div>
<div class="section level5">
<h5 id="what-is-whiplash">What is whiplash?<a class="anchor" aria-label="anchor" href="#what-is-whiplash"></a>
</h5>
<p>We coined the term whiplash to describe two back-to-back excursions
that roughly form a sinusoid. These sinusoidal excursions pose a problem
for identifying the true peaks and nadirs defining an excursion since
the moving average is a lagging indicator. In other words, at the end of
one period of a sinusoidal excursion, the long moving average will be
approximately equal to the short moving average (i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><msub><mi>A</mi><mrow><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>x</mi><mo accent="true">→</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mo>≈</mo><mi>M</mi><msub><mi>A</mi><mrow><mi>s</mi><mi>h</mi><mi>o</mi><mi>r</mi><mi>t</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>x</mi><mo accent="true">→</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mo>≈</mo><mover><mi>x</mi><mo accent="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">MA_{long}(\vec x)\approx MA_{short}(\vec x)\approx \bar x</annotation></semantics></math>).
Since the moving average is a lagging indicator, by the time a cross
between the short and long moving average occurs, the true peak or nadir
indicating the start of an excursion may have already occurred. Thus,
starting in MAGE iglu v3.5.1, we calculate turning points sequentially
between
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><msub><mi>p</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">tp_{i-1}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><msub><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">cp_{i+1}</annotation></semantics></math>
as compared to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">cp_i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><msub><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">cp_{i+1}</annotation></semantics></math>,
previously. See the difference in the identified
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><msub><mi>p</mi><mn>12</mn></msub></mrow><annotation encoding="application/x-tex">tp_{12}</annotation></semantics></math>
in the images below, the first being MAGE iglu v3.5.1 (whiplash
corrected) and the second MAGE iglu v3.5.0 (whiplash not corrected).</p>
<p><img src="mage_figures/whiplash1.png" width="700px" height="400px"></p>
<p><strong>Figure 5.</strong> Plot of Subject 1636-69-026 via MAGE iglu
v3.5.1 with correction for whiplash. Notice the true peak is properly
identified for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><msub><mi>p</mi><mn>12</mn></msub></mrow><annotation encoding="application/x-tex">tp_{12}</annotation></semantics></math>.</p>
<p><img src="mage_figures/whiplash2.png" width="700px" height="400px"></p>
<p><strong>Figure 6.</strong> Plot of Subject 1636-69-026 via MAGE iglu
v3.5.0 without whiplash corrected for. Notice the true peak is not
properly identified for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><msub><mi>p</mi><mn>12</mn></msub></mrow><annotation encoding="application/x-tex">tp_{12}</annotation></semantics></math>.</p>
</div>
<div class="section level5">
<h5 id="why-set-a-default-of-180-minutes-for-max_gap">Why set a default of 180 minutes for <code>max_gap</code>?<a class="anchor" aria-label="anchor" href="#why-set-a-default-of-180-minutes-for-max_gap"></a>
</h5>
<p>The purpose of <code>max_gap</code> is to split the CGM trace into
different logical segments - i.e., there are so many missing values
between segments 1 and 2 that it makes more sense to treat them as
separate than as one continuous trace. For example, say a patient wears
their CGM on Monday and Wednesday but forgets on Tuesday. There would be
a stretch of 24-h of missing data! Thus, it makes more sense to
calculate MAGE on Monday and Wednesday independently, as we cannot
extrapolate what occurred in the time in-between.</p>
<p>While it is fairly obvious in the above example that we should
segment the CGM trace, what about shorter stretches of missing data?
Since the purpose of MAGE is to calculate the mean amplitude of glycemic
<em>excursions</em>, the ideal <code>max_gap</code> will split the trace
when there is a possibility of missing an excursion. Since post-prandial
excursions typically last a maximum of 180 minutes [citation needed], we
chose 180 minutes as an acceptable default threshold. To explain in
natural language: if we have &gt;180 minutes of missing data, we likely
have missed either an entire excursion or multiple excursions, so we
treat the trace as two distinct segments.</p>
</div>
</div>
<div class="section level2">
<h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<p>[1] Kovatchev BP. Metrics for glycemic control—from HbA1c to
continuous glucose monitoring. Nature Reviews Endocrinology. 2017
Jul;13(7):425-36.</p>
<p>[2] Service FJ. Glucose variability. Diabetes. 2013
May;62(5):1398-404.</p>
<p>[3] Service FJ, Molnar GD, Rosevear JW, Ackerman E, Gatewood LC,
Taylor WF. Mean amplitude of glycemic excursions, a measure of diabetic
instability. Diabetes. 1970 Sep 1;19(9):644-55.</p>
<p>[4] Yu X, Lin L, Shen J, Chen Z, Jian J, Li B, Xin SX. Calculating
the mean amplitude of glycemic excursions from continuous glucose data
using an open-code programmable algorithm based on the integer nonlinear
method. Computational and mathematical methods in medicine. 2018 Mar
8;2018.</p>
<p>[5] Hill NR, Oliver NS, Choudhary P, Levy JC, Hindmarsh P, Matthews
DR. Normal reference range for mean tissue glucose and glycemic
variability derived from continuous glucose monitoring for subjects
without diabetes in different ethnic groups. Diabetes technology &amp;
therapeutics. 2011 Sep 1;13(9):921-8.</p>
<p>[6] Pagacz K, Stawiski K, Szadkowska A, Mlynarski W, Fendler W.
GlyCulator2: an update on a web application for calculation of glycemic
variability indices. Acta diabetologica. 2018 Aug;55(8):877-80.
<!--https://apps.konsta.com.pl/app/glyculator/ Date Accessed: March 11, 2021. --></p>
<p>[7] Vigers T, Chan CL, Snell-Bergeon J, Bjornstad P, Zeitler PS,
Forlenza G, Pyle L. cgmanalysis: an R package for descriptive analysis
of continuous glucose monitor data. Plos one. 2019 Oct
11;14(10):e0216851.</p>
<p>[8] Broll S, Urbanek J, Buchanan D, Chun E, Muschelli J, Punjabi NM,
Gaynanova I. Interpreting blood GLUcose data with R package iglu. Plos
one. 2021 Apr 1;16(4):e0248560.</p>
<p>[9] Bent B. cgmquantify: python package for analyzing glucose and
glucose variability. Python package version 0.5. 2020 Nov 11. <a href="https://github.com/brinnaebent/cgmquantify" class="external-link uri">https://github.com/brinnaebent/cgmquantify</a> Date
Accessed: March 11, 2021.</p>
<p>[10] Fritzsche G, Kohnert KD, Heinke P, Vogt L, Salzsieder E. The use
of a computer program to calculate the mean amplitude of glycemic
excursions. Diabetes technology &amp; therapeutics. 2011 Mar
1;13(3):319-25</p>
<p>[11] Baghurst PA. Calculating the mean amplitude of glycemic
excursion from continuous glucose monitoring data: an automated
algorithm. Diabetes technology &amp; therapeutics. 2011 Mar
1;13(3):296-302.</p>
<p>[12] Sechterberger MK, Luijf YM, DeVries JH. Poor agreement of
computerized calculators for mean amplitude of glycemic excursions.
Diabetes technology &amp; therapeutics. 2014 Feb 1;16(2):72-5.</p>
<p>[13] Martin M, Chun E, Buchanan D, Bhat R, Cass S, Wang E, Senthil S,
Gaynanova I. irinagain/Awesome-CGM: List of public CGM datasets (Version
v1.1.0). 2021, April 27. <a href="https://github.com/irinagain/Awesome-CGM" class="external-link uri">https://github.com/irinagain/Awesome-CGM</a> Date Accessed:
May 1, 2021.</p>
<p>[14] Hall H, Perelman D, Breschi A, Limcaoco P, Kellogg R, McLaughlin
T, Snyder M. Glucotypes reveal new patterns of glucose dysregulation.
PLoS biology. 2018 Jul 24;16(7):e2005143.</p>
<p>[15] Tsalikian E, Mauras N, Beck RW, Tamborlane WV, Janz KF, Chase
HP, Wysocki T, Weinzimer SA, Buckingham BA, Kollman C, Xing D. Impact of
exercise on overnight glycemic control in children with type 1 diabetes
mellitus. The Journal of pediatrics. 2005 Oct;147(4):528-34.</p>
<p>[16] Dubosson F, Ranvier JE, Bromuri S, Calbimonte JP, Ruiz J,
Schumacher M. The open D1NAMO dataset: A multi-modal dataset for
research on non-invasive type 1 diabetes management. Informatics in
Medicine Unlocked. 2018 Jan 1;13:92-100.</p>
<p>[17] Broll S, Buchanan D, Chun E, Muschelli J, Fernandes N, Seo J,
Shih J, Urbanek J, Schwenck J, Gaynanova I. iglu: Interpreting Glucose
Data from Continuous Glucose Monitors. R package version 3.0.0. 2021
July 23. <a href="https://cran.r-project.org/package=iglu" class="external-link uri">https://cran.r-project.org/package=iglu</a>. Date Accessed:
July 23, 2021.</p>
<p>[18] Olawsky, Evan, et al. “A new analysis tool for continuous
glucose monitor data.” <em>Journal of diabetes science and
technology</em> 16.6 (2022): 1496-1504.</p>
<p>[19] Cappon, Giacomo, Giovanni Sparacino, and Andrea Facchinetti.
“AGATA: a toolbox for automated glucose data analysis.” <em>Journal of
Diabetes Science and Technology</em> (2023): 19322968221147570.</p>
<p>[20] Attaye, Ilias, et al. “Introducing the Continuous Glucose Data
Analysis (CGDA) R Package: an intuitive package to analyze continuous
glucose monitoring data.” <em>Journal of diabetes science and
technology</em> 16.3 (2022): 783-785.</p>
<p>[21] <a href="https://github.com/rolandhangelbroek" class="external-link">rolandhangelbroek</a>. “CGM
Shiny”. GitHub: <a href="https://github.com/rolandhangelbroek/cgmshiny" class="external-link uri">https://github.com/rolandhangelbroek/cgmshiny</a>.</p>
<p>[22] Zaccardi, Francesco, et al. “Group of signs: a new method to
evaluate glycemic variability.” <em>Journal of diabetes science and
technology</em> 2.6 (2008): 1061-1065.</p>
<p>[23] Syafa’ah, Lailis, Mauridhi Hery Purnomo, and Setio Basuki.
“Discrete mean amplitude of glycemic excursion (MAGE) measurement on
diabetics with spline interpolation method.” <em>International Journal
on Electrical Engineering and Informatics</em> 10.2 (2018): 259-270.</p>
<p>[24] Hendaryati, Heni, Askandar Tjokroprawir, and Lailis Syafa’ah.
“Measurement of MAGE (Mean Amplitude of Glycemic Excursion) at Diabetics
with Interpolation Method.” <em>Research Report</em> (2017): 79-87.</p>
<p>[25] Marics, Gábor, et al. “Evaluation of an open access software for
calculating glucose variability parameters of a continuous glucose
monitoring system applied at pediatric intensive care unit.”
<em>Biomedical engineering online</em> 14 (2015): 1-13.</p>
<p>[26] Shao, Jian, Tao Xu, and Kaixin Zhou. “CGMTSA: An R package for
continuous glucose monitoring time series data analysis.”
<em>bioRxiv</em> (2020).</p>
<p>[27] Piersanti, Agnese, et al. “Software packages and tools for the
analysis of continuous glucose monitoring data.” <em>Diabetes Technology
&amp; Therapeutics</em> 25.1 (2023): 69-85.</p>
<p>[28] Chrzanowski, Jędrzej, et al. “Glyculator 3.0: A fast,
easy-to-use Analytical tool for CGM data analysis, aggregation, center
Benchmarking, and data sharing.” <em>Diabetes Care</em> 46.1 (2023):
e3.</p>
<p>[29] Rawlings, Renata A., et al. “Translating Glucose Variability
Metrics into the Clinic via C ontinuous G lucose M onitoring: AG
raphical U ser I nterface for D iabetes E valuation (CGM-GUIDE©).”
<em>Diabetes technology &amp; therapeutics</em> 13.12 (2011):
1241-1248.</p>
<p>[30] “Tidepool,” <em>www.tidepool.org</em>. <a href="https://www.tidepool.org/" class="external-link uri">https://www.tidepool.org/</a>.</p>
<p>[31] Millard, Louise AC, et al. “GLU: a software package for
analysing continuously measured glucose levels in epidemiology.”
<em>International Journal of Epidemiology</em> 49.3 (2020): 744-757.</p>
<p>[32] Zhang, Xiaohua Douglas, Zhaozhi Zhang, and Dandan Wang.
“CGManalyzer: an R package for analyzing continuous glucose monitoring
studies.” <em>Bioinformatics</em> 34.9 (2018): 1609-1611.</p>
<p>[33] Rodbard, David. “New and improved methods to characterize
glycemic variability using continuous glucose monitoring.” Diabetes
technology &amp; therapeutics 11.9 (2009): 551-565.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Elizabeth Chun, Steve Broll, David Buchanan, John Muschelli, Nathaniel Fernandes, Irina Gaynanova.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.0.</p>
</div>

    </footer>
</div>





  </body>
</html>
